== BEMとは何か？
##BEM## とはブロック（Block）、エレメント（Element）、モディファイア（Modifier）の略語である。
その意味についてはこの記事で明らかにしていこう。

プログラミングにおける方法論の最も一般的なものはオブジェクト指向プログラミング（Object-Oriented Programming）だろう。
その枠組みは多くの言語で具体化されている。
BEMはいくつかの点でオブジェクト指向プログラミングと似ている。
それは現実のものをコードとして表現する方法であり、一連のパターンであり、また使用しているプログラミング言語とは関係なくプログラムの本質について考える方法である。

私たちはBEMの原則をフロントエンド開発のテクニックとツールをつくり上げるために用いたことで、Webサイトを迅速に開発し、長期間に渡ってメンテナンスし続けることができるようになった。

=== 統一されたデータドメイン（Unified Data Domain）
次の図のような一般的なWebサイトを思い浮かべてみよう。

%%html
<div style="text-align:center">
<img src="images/site.png"/>
</div>
%%

このようなWebサイトの開発中には、サイトを構成するものを「ブロック」として区別しておくと役立つ。

例えばこの図では、##ヘッダ##、##メインレイアウト##、それに##フッター##ブロックがある。
##ヘッダ##は##ロゴ##、##検索##、##認証ブロック##に##メニュー##で構成されている。
##メインレイアウト##は、##ページタイトル##や##テキストブロック##を含んでいる。

%%html
<div style="text-align:center">
<img src="images/site-marked.png"/>
</div>
%%

ページの各部分に名前を付けるのは、チームでのコミュニケーションにとても役立つ。

プロジェクトマネージャーはこんな風に質問できる:
 * ##ヘッダー##を大きくしてくれ
 * ##ヘッダ##の中に##検索##フォームを含まないページを作ってほしい

HTML開発者は仲間のJavaScript開発者にこんな伝え方ができる:
 * ##認証ブロック##をアニメーションさせてくれ

それでは、BEMを構成する要素について詳しく見ていこう:

==== ブロック（Block）
##ブロック##は独立した存在で、アプリケーションの「構成要素」である。
ブロックには単体のものも複合物（他のブロックを含むもの）もある。

**例**\\
検索フォームブロック\\

%%html
<div style="text-align:center">
<img src="images/search-block.png"/>
</div>
%%

==== エレメント（Element）
##エレメント##は、ブロックの一部分であり特定の働きを持つ。
エレメントは文脈依存であり、そのエレメントが属するブロック内でのみ意味をなす。

**例**\\
入力フィールドとボタンは検索ブロックのエレメント

%%html
<div style="text-align:center">
<img src="images/search-block-marked.en.png"/>
</div>
%%

=== Means of describing pages and templates
ブロックとエレメントはページコンテンツの構成要素となる。
単にページ上に存在するということ加えて、それらの配置も重要である。

ブロック（またはエレメント）は、決まった順序でお互いに並ぶことができる。

例えば、コマースサイトの商品リスト:

%%html
<div style="text-align:center">
<img src="images/goods-list.png"/>
</div>
%%

…もしくはメニューアイテム:

%%html
<div style="text-align:center">
<img src="images/menu-items.png"/>
</div>
%%

ブロックはその内部に他のブロックを含むこともできる。

例えば、他のブロックを含む##ヘッダーブロック##:

%%html
<div style="text-align:center">
<img src="images/head-marked.png"/>
</div>
%%

これらの構成要素がある一方で、プレーンテキストでページレイアウトを記述することも必要である。
そのためには、すべてのブロックとエレメントはそれを識別するためのキーワードを持つ必要がある。

特定のブロックを指すキーワードは##block name##となる。

例えば、##menu##は##メニューブロック##のキーワードとなり、##head##は##ヘッダー##ブロックのキーワードとなる。

特定のエレメントを指すキーワードは##element name##となる。

例えば、メニューの各アイテムは##menu##ブロックの##item##エレメントである。

ブロック名（##block name##）は、明確にどのブロックを指すかを表現できなければならないため、プロジェクト内で一意である必要がある。
同じブロックの唯一のインスタンスは同じ名前を持つことができる（訳注：シングルトン的な認識をするブロックの場合、ということと思われる）。

その場合、ある1つのブロックがページに2回（3回、4回、…）と表れる、と表現することになる。

エレメント名はそのブロックのスコープ内で一意である必要がある。
エレメントは何度も繰り返すことができる。

例えばメニューアイテムの場合:

%%html
<div style="text-align:center">
<img src="images/menu-items.png"/>
</div>
%%

キーワードは特定の順序で表れる必要がある。

ネストをサポートしたデータフォーマットではこうなる:

%%hl xml
<b:page>
  <b:head>
    <b:menu>
      …
    </b:menu>
    <e:column>
      <b:logo/>
    </e:column>
    <e:column>
      <b:search>
        <e:input/>
        <e:button>Search</e:button>
      </b:search>
    </e:column>
    <e:column>
      <b:auth>
        …
      </b:auth>
    <e:column>
  </b:head>
</b:page>
%%

このXMLの例では、##b##と##e##の名前空間がエレメントノードとブロックノードを分離している。

同じものをJSONで表現した場合:

%%hl js
{
  block: 'page',
  content: {
    block: 'head',
    content: [
      { block: 'menu', content: … },
      {
        elem: 'column',
        content: { block: 'logo' }
      },
      {
        elem: 'column',
        content: [
          {
            block: 'search',
            content: [
              { elem: 'input' },
              { elem: 'button', content: 'Search' }
            ]
          }
        ]
      },
      {
        elem: 'column',
        content: {
          block: 'auth', content: …
        }
      }
    ]
  }
}
%%

上記の例はブロックとエレメントが互いにネストしたオブジェクトモデルを表現している。
この構造では、任意の数のカスタムデータフィールドを含めることができる。

私たちはこの構造を##BEMツリー##と読んでいる（DOMツリーからの類推で）。

テンプレートの変換（XSLやJavaScriptを使うなどした）をして生成された、ブラウザに渡されるマークアップはBEMツリーとなる。

ブロックをページ上の別の位置に移動させる必要がある場合、開発者はBEMツリーを変更することで行う。最終的な外観は、テンプレート自身が生成する。

BEMツリーを表現するフォーマットやテンプレートエンジンには、任意のものを使うことができる。

私たちはページを表現するフォーマットにJSONを用いており、BEMHTMLというJavaScriptベースのテンプレートエンジンによってHTMLに変換している。

=== ブロックの非依存
As projects grow, blocks tend to be added, removed, or moved around the page. For example,
you may want to swap the ##Logo## and ##Auth Block## or to place the ##Menu## under the
##Search Block##.

%%html
<div style="text-align: center">
<img src="images/head.png"/>
</div>
%%

%%html
<div style="text-align: center">
<img src="images/head-changed.png"/>
</div>
%%

To make this process easier, blocks must be ##independent##.

An ##independent## block is implemented in a way that allows arbitrary placement —
anywhere on the page, including nesting inside another block.

====Independent CSS
From the CSS point of view it means that

 * A block (or an element) must have a unique "name" (a CSS class) that could be used in a CSS rule.
 * HTML elements must not be used in CSS selectors (##.menu td##) as such selectors are inherently
   not context-free.
 * Cascading selectors should be avoided.

===== Naming for independent CSS classes
Here's one of the possible CSS class naming scheme:

 * CSS class for a block coincides with its ##block name##
%%hl xml
<ul class="menu">
  …
</ul>
%%
 * CSS class for an element is a ##block name## and an ##element name## separated
 by some character(s)
%%hl xml
<ul class="menu">
  <li class="menu__item">…</li>
  <li class="menu__item">…</li>
</ul>
%%

It is necessary to include block name into a CSS class for an element to minimize cascading.

It is also important to use separators consistently to allow the tools and helpers (described
further) unambiguous programmatic access to the elements.

We use hyphen to separate words in long names (for example, ##block-name##) and two underscores
to separate the name of the block form the name of the element (##block-name_~_element-name##).

But you can use any other separators for it.

E.g.:
  * ##block-name-~-element-name## or
  * ##blockName-elementName##

==== Independent templates
From the template engine's perspective, block independence means that:

 * Blocks and elements must be described in the input data\\
   Blocks (or elements) must have unique "names" to make things like "##Menu## should be
   placed here" expressible in our templates.
 * Blocks may appear anywhere in a BEM tree

===== Independent templates for blocks
Coming upon a block in a template, the template engine should be able to unambiguously transform
it into HTML. Thus, every block should have a template for that.

For example, a template can look like this in XSL:

%%hl xml
<xsl:template match="b:menu">
  <ul class="menu">
    <xsl:apply-templates/>
  </ul>
</xsl:template>

<xsl:template match="b:menu/e:item">
  <li class="menu__item">
    <xsl:apply-templates/>
  </li>
<xsl:template>
%%

We are gradually discarding XSLT in our products in favor of our own JavaScript-based
template engine ((https://github.com/veged/xjst XJST)). This template engine absorbs everything
we like about XSLT (we are fans of declarative programming), and implements it with JavaScript's
productivity on either client or server side.

We write our templates using a domain-specific language called BEMHTML, which is based on XJST.
((/articles/bemhtml-reference/ The main ideas of BEMHTML)).

((https://github.com/bem/bem-bl/tree/master/blocks-common/i-bem/__html BEMHTML))

=== Blocks Reiteration
The second ##Menu Block## can occur in the ##Foot Block## of a site. Or, a ##Text Block##
can turn into two, separated by an advertisement.

Even if a block was developed as a singular unit, the same one can appear on a page at any moment.

In CSS related terms, it means:
 * ID-based CSS selectors must not be used\\
   Only class selectors satisfy our non-uniqueness requirement.

On the JavaScript side it means:
 * Blocks with similar behavior are detected unequivocally: they have the same CSS classes\\
   Using CSS class selectors allow picking all blocks with a given name to apply the required
   dynamic behavior.

=== Modifiers for Blocks
We often need to create a block very similar to an existing one, but with slightly altered
its appearance or behavior.

Let's say, we have a task:
 * Add another ##Menu## in the ##Footer## with a //different layout//.

%%html
<div style="text-align: center">
<img src="images/site-footer-menu.png"/>
</div>
%%

To avoid developing another block that is only minimally different from an existing one,
we can use a ##modifier##.

A ##modifier## is a property of a block or an element that alters its look or behavior.

A modifier has a name and a value. Several modifiers can be used at once.

**Example**\\
A block modifier specifies background color

%%html
<div style="text-align: center">
<img src="images/search-background.png"/>
</div>
%%

**Example**\\
An element modifier changes the look of the "current" item

%%html
<div style="text-align: center">
<img src="images/menu-current-item.png"/>
</div>
%%

==== From the input data point of view
In a BEM tree, modifiers are properties of an entity that describes a block or an element.

For example, they can be attribute nodes in XML:

%%hl xml
<b:menu m:size="big" m:type="buttons">
  …
</b:menu>
%%

The same expressed in JSON:

%%hl js
{
  block: 'menu',
  mods: [
   { size: 'big' },
   { type: 'buttons' }
  ]
}
%%

==== From the HTML/CSS point of view
A modifier is an additional CSS class for a block or an element.

%%hl xml
<ul class="menu menu_size_big menu_type_buttons">
  …
</ul>
%%

%%hl css
.menu_size_big {
  // CSS code to specify height
}
.menu_type_buttons .menu__item {
  // CSS code to change item's look
}
%%

Мы используем одно подчёркивание для отделение имени модификатора от имени блока и
ещё одно подчёркивание для отделения значения модификатора от его имени.

=== Element modifiers
Element modifiers are implemented in the same fashion.

Again, when writing CSS by hand, it is very important to use separators consistently for programmatic access.

E.g., current menu item can be marked with a modifier:

%%hl xml
<b:menu>
  <e:item>Index<e:item>
  <e:item m:state="current">Products</e:item>
  <e:item>Contact<e:item>
</b:menu>
%%

%%hl js
{
  block: 'menu',
  content: [
    { elem: 'item', content: 'Index' },
    {
      elem: 'item',
      mods: { 'state' : 'current' },
      content: 'Products'
    },
    { elem: 'item', content: 'Contact' }
  ]
}
%%

%%hl css
.menu__item_state_current
{
  font-weight: bold;
}
%%

Which could be represented in HTML as follows:

%%hl xml
<ul class="menu">
  <li class="menu__item">Index</li>
  <li class="menu__item menu__item_state_current">Products</li>
  <li class="menu__item">Contact</li>
</ul>
%%

Or to make menu classes independent of the implementation details of its layout:

%%hl xml
<div class="menu">
  <ul class="menu__layout">
    <li class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </li>
  </ul>
</div>
%%

%%hl xml
<div class="menu">
  <table class="menu__layout">
  <tr>
    <td class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </td>
    <td class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </td>
    <td class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </td>
  </tr>
  </table>
</div>
%%

=== Subject-Matter Abstraction
When many people work on a project they should agree on a data domain and use it
when naming their blocks and elements.

For example, a ##Tag Cloud## block is always named ##tags##. Each of its elements is a
##tag##. This convention spreads across all languages: CSS, JavaScript, XSL, etc.

From the development process' point of view:
 * All participants operate on the same terms

From the CSS point of view:
 * CSS for blocks and elements can be written in a pseudo language that compiles
   down to CSS according to the naming convention.

%%hl css
  .menu {
    __layout {
      display: inline;
    }
    __layout-item {
      display: inline-block;
      …
    }
    __item {
      _state_current {
        font-weight: bold;
      }
    }
  }
%%

On the JavaScript side:
 * Instead of using class selectors directly to find DOM elements, a special helper
   library may be used:

%%hl js
$('menu__item').click( … );
$('menu__item').addClass('menu__item_state_current');
$('menu').toggle('menu_size_big').toggle('menu_size_small');
%%

The naming convention for CSS classes of blocks and elements can change in the course of
time. Using special JavaScript functions to access blocks and elements and to work with their
modifiers makes it possible to change only these functions if the naming convention changes.

%%hl js
block('menu').elem('item').click( … );
block('menu').elem('item').setMod('state', 'current');
block('menu').toggleMod('size', 'big', 'small');
%%

The code above is abstract. In real life we use the JavaScript core of ##i-bem## block
from the ##bem-bl## block library:
 ((http://bem.github.com/bem-bl/sets/common-desktop/i-bem/i-bem.en.html))

=== Blocks consistency
A site has a ##Button## block with certain dynamic behavior.

%%html
<div style="text-align: center">
<img src="images/button.png"/>
</div>
%%

When a block is hovered, it changes its appearance.

%%html
<div style="text-align: center">
<img src="images/button-cursor.png"/>
</div>
%%

A manager could ask to use the same button on another page.

Having a CSS implementation of a block is not enough. Reusing a block also means reusing its
behavior, described in JavaScript.

So a block must "know" everything about itself. To implement a block we describe its appearance
and behavior in all technologies being used - we call that ##multilingualism##.

##Multilingual## presentation is a description of a block in all the programming languages (techs)
that are necessary to implement the view and the functionality of a block.

To have a block present on a page as a UI element we need to implement it in the following techs:
 * Templates (XSL, TT2, JavaScript, etc), which turn block declarations into HTML code
 * CSS that describes appearance of the block
 * A JavaScript implementation for the block, if a block has dynamic behavior
 * Images
 * Documentation

Everything that constitutes a block is a block technology.

=== Real examples
((http://company.yandex.ru Yandex)) is a large (mostly Russian) company that
use BEM methodology to develop its services.

BEM methodology does not request you to use certain framework. You also don't
have to use BEM for all the technologies you have on your pages (but that would
be the most efficient).

((http://www.yandex.ru/all All the services of Yandex)) have BEM in their
CSS and JavaScript code and XSL templates of the pages. E.g.,
 * ((http://maps.yandex.ru/?text=%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F%2C%20%D0%9C%D0%BE%D1%81%D0%BA%D0%B2%D0%B0&sll=37.609218%2C55.753559&ll=37.609218%2C55.753563&spn=2.570801%2C0.884460&z=9&l=map Yandex.Maps))
 * ((http://images.yandex.ru/yandsearch?text=Yandex+office&rpt=image Yandex.Images))\\
   This is a service for searching images in the Internet.
 * ((http://video.yandex.ru/#search?text=yac%202011 Yandex.Video))\\
   This is a service for both hosting and searching images.
 * ((http://auto.yandex.ru/ Yandex.Auto))
 * ((http://www.yandex.com.tr/ Turkish Yandex))

Some services don't use XSL templates and build their pages with our newest template
product, ##bemhtml## template engine which was mentioned above. These are the following
services:
 * ((http://yandex.ru/yandsearch?text=BEM+methodology+front-end&lr=213 Yandex Search))\\
   or ((http://yandex.com/yandsearch?text=%22What+is+BEM%3F%22+front-end&lr=213 Yandex Search in English))
 * ((http://apps.yandex.ru/ Mobile Apps Search))\\
   This site is to look under smartphones.

There are also other companies that use BEM methodology.

For example, guys in ((http://mail.ru Mail.ru)) partly use BEM for their services.
Some blocks on their pages are BEM-based in terms of CSS code. They also have their
own C++ template engine and write block templates according to the methodology.

More examples:
 * ((http://beta.news.rambler.ru/ Rambler.News))
 * ((http://hh.ru/ HeadHunter))
 * ((http://futurecolors.ru/tnkracing/ TNK Racing Team))

You may also be interested in sites that use ((http://bem.github.com/bem-bl/index.ru.html bem-bl)) block library:
 * ((http://form.dev.eot.su/ BEM based web form with JZ validation))
 * ((http://mishanga.pro/ Mikhail Troshev vCard))\\
   Source code is hosted at GitHub: ((https://github.com/mishanga/bem-vcard))

=== もっと読む
  * 定義
  * ((../filesystem/ ファイル構成))
  * ((../history/ 歴史))
